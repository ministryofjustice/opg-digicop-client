name: Branch
on:
  push:
    branches-ignore: [ main ]
  pull_request:
    branches-ignore: [ main ]
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  select_project:
    runs-on: ubuntu-latest
    outputs:
      new_project: ${{ steps.check-branch.outputs.new }}
      old_project: ${{ steps.check-branch.outputs.old }}
    steps:
      - uses: actions/checkout@v2
      - name: check branch
        id: check-branch
        run: |
          if [[ ${{ github.ref }} =~ ^refs/heads/SER-[0-9]* ]]; then
              echo ::set-output name=new::true
          elif [[ ${{ github.ref }} =~ ^refs/heads/DDPB-[0-9]* ]]; then
              echo ::set-output name=old::true
          else
            echo "Please use a SER or DDPB prefix for your branch name!"
            exit 1
          fi
          echo $WORKSPACE

  cancel_redundant_builds:
    runs-on: ubuntu-latest
    steps:
      - name: Cancel redundant builds
        id: check-branch
        run: echo "Cancelling redundant builds"

  build_and_test:
    runs-on: ubuntu-latest
    needs: [cancel_redundant_builds, select_project]
    if: needs.select_project.outputs.new_project == 'true'
    env:
      working-directory: ./_serve-opg-new
    steps:
      - uses: actions/checkout@v2
      - uses: actions/cache@v2
        id: cache
        with:
          path: ./_serve-opg-new/
          key: ${{ runner.os }}-${{ hashFiles('**/*.lock') }}
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        timeout-minutes: 60
        with:
          limit-access-to-actor: true
      - name: Prepare localstack
        working-directory: ${{env.working-directory}}
        run: |
          # pip install --quiet awscli
          # Create the s3 buckets & wait for the server to become available
          docker-compose up -d localstack
          docker-compose run --rm waitforit -address=http://localstack:4572 -debug -timeout=30
          docker-compose run --rm aws --endpoint-url=http://localstack:4572 s3 mb s3://sirius_test_bucket
          docker-compose run --rm aws --endpoint-url=http://localstack:4572 s3 mb s3://test_bucket
          # Create dynamodb tables
          docker-compose run --rm aws --region eu-west-1 --endpoint-url=http://localstack:4569 dynamodb create-table --cli-input-json file://attempts_table.json
          docker-compose run --rm aws --region eu-west-1 --endpoint-url=http://localstack:4569 dynamodb create-table --cli-input-json file://sessions_table.json
      - name: Create dependencies
        working-directory: ${{env.working-directory}}
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          # Triggers Symfony Flex to run recipes during composer install - required for phpunit-bridge
          rm -rf vendor
          rm -rf symfony.lock
          # Vendor php dependencies
          docker-compose run --rm app composer install --no-interaction
          # Install js dependencies
          docker-compose run --rm yarn install
          # Generate static assets
          docker-compose run --rm yarn build-dev
          # Removes boilerplate feature test added during Symfony Flex recipe for behat
          rm -rf features/demo.feature
      - name: Build
        working-directory: ${{env.working-directory}}
        run: |
          # Generate static assets
          docker-compose run --rm yarn build
          # Build app
          docker-compose build web
          docker-compose build app
      - name: List packages and versions
        working-directory: ${{env.working-directory}}
        run: |
          docker-compose run --rm web apk list | sort
          docker-compose run --rm app apk list | sort
          docker-compose run --rm app php -v
      - name: Unit test PHP
        working-directory: ${{env.working-directory}}
        run: |
          ./generate_certs.sh
          docker-compose -f docker-compose.test.yml -f docker-compose.yml up -d loadbalancer
          docker-compose run --rm waitforit -address=tcp://loadbalancer:443 -debug -timeout 120
          docker-compose run --rm waitforit -address=tcp://postgres:5432 -debug
          docker-compose -f docker-compose.test.yml -f docker-compose.yml run --rm app php bin/phpunit --verbose tests --log-junit /var/www/tests/artifacts/phpunit/junit.xml
      - name: Unit tests Golang
        working-directory: ${{env.working-directory}}
        run: echo "Running Go tests"
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1
      - name: Push to ECR
        working-directory: ${{env.working-directory}}
        run: |
          docker images
          aws ecr get-login --region eu-west-1 --no-include-email --profile serve-opg-ci
          docker-compose push app
          docker tag 311462405659.dkr.ecr.eu-west-1.amazonaws.com/serve-opg/app:latest 311462405659.dkr.ecr.eu-west-1.amazonaws.com/serve-opg/app:${GITHUB_SHA::7}
          docker push 311462405659.dkr.ecr.eu-west-1.amazonaws.com/serve-opg/app:${GITHUB_SHA::7}
          docker-compose push web
          docker tag 311462405659.dkr.ecr.eu-west-1.amazonaws.com/serve-opg/web:latest 311462405659.dkr.ecr.eu-west-1.amazonaws.com/serve-opg/web:${GITHUB_SHA::7}
          docker push 311462405659.dkr.ecr.eu-west-1.amazonaws.com/serve-opg/web:${GITHUB_SHA::7}

  build_infrastructure:
    runs-on: ubuntu-latest
    needs: [build_and_test]
    if: needs.select_project.outputs.new_project == 'true'
    env:
      working-directory: ./_serve-opg-new/terraform/environment
    steps:
      - uses: actions/checkout@v2
      - name: Plan terraform
        working-directory: ${{env.working-directory}}
        run: echo "planning terraform on branch"
      - name: Apply terraform
        working-directory: ${{env.working-directory}}
        run: echo "applying terraform on branch"
      - name: Protect branch in dynamodb
        working-directory: ${{env.working-directory}}
        run: echo "protecting branch"

  integration_tests:
    runs-on: ubuntu-latest
    needs: [build_infrastructure]
    if: needs.select_project.outputs.new_project == 'true'
    steps:
      - uses: actions/checkout@v2
      - name: Integration tests
        working-directory: ./_serve-opg-new/terraform/environment
        run: echo "running integration tests against branch env"

  plan_main_environments:
    runs-on: ubuntu-latest
    needs: [build_infrastructure]
    if: needs.select_project.outputs.new_project == 'true'
    steps:
      - uses: actions/checkout@v2
      - name: Plan development shared
        working-directory: ./_serve-opg-new/terraform/shared
        run: echo "running development shared plan"
      - name: Plan preproduction shared
        working-directory: ./_serve-opg-new/terraform/shared
        run: echo "running preproduction shared plan"
      - name: Plan production shared
        working-directory: ./_serve-opg-new/terraform/shared
        run: echo "running production shared plan"
      - name: Plan development environment
        working-directory: ./_serve-opg-new/terraform/environment
        run: echo "running dev plan"
      - name: Plan preproduction environment
        working-directory: ./_serve-opg-new/terraform/environment
        run: echo "running preproduction plan"
      - name: Plan production environment
        working-directory: ./_serve-opg-new/terraform/environment
        run: echo "running production plan"

  branch_ready:
    runs-on: ubuntu-latest
    needs: [plan_main_environments, integration_tests]
    if: needs.select_project.outputs.new_project == 'true'
    environment:
      name: branch
    steps:
      - uses: actions/checkout@v2
      - name: Unprotect environment
        working-directory: ./_serve-opg-new
        run: echo "Unprotecting Environment"
      - name: Notify slack
        working-directory: ./_serve-opg-new
        run: echo "Notifying slack"

  kick_off_old_wf:
    runs-on: ubuntu-latest
    needs: [cancel_redundant_builds, select_project]
    if: needs.select_project.outputs.old_project == 'true'
    steps:
      - name: Kick off old workflow
        run: |
         BRANCH=${GITHUB_REF##*/}
         curl --request POST \
           --url https://circleci.com/api/v2/project/github/ministryofjustice/serve-opg/pipeline \
           --header 'Circle-Token: ${{ secrets.CIRCLE_API_KEY }}' \
           --header 'content-type: application/json' \
           --data '{"parameters":{"run_legacy_pipeline":true}, "branch": "${BRANCH}"}'



